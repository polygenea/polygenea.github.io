<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<style type="text/css">
body{font-family:sans-serif;}
code{font-family:monospace;font-size:100%;background-color:#eee;border:1px solid #aaa; padding:1px; border-radius:4px;}
table{border-collapse:collapse;}
tr:nth-child(2n){background-color:#ddd;}
td,th{padding:0.25ex 1ex;}
th{border-bottom:1px solid black;}
</style>



<p>This is a work-in-progress overview of polygenea, a model for representing family history and genealogical research.</p>
<h1 id="specification-of-reasoning">Specification of Reasoning</h1>
<h2 id="basic-datatypes">Basic Datatypes</h2>
<dl>
<dt><strong>character</strong></dt>
<dd><p>an atomic unit of text as specified by <code>ISO/IEC 10646</code>.</p>
</dd>
<dt><strong>string</strong></dt>
<dd><p>a finite-length sequence of characters.</p>
</dd>
<dt><strong>octet</strong></dt>
<dd><p>a sequence of eight bits, each either 0 or 1.</p>
</dd>
<dt><strong>blob</strong></dt>
<dd><p>a finite-length sequence of octets.</p>
</dd>
<dt><strong>datum</strong></dt>
<dd><p>a (string, string, blob) tuple. Each string specifies part of the interpretation of the blob; they mean (in order)</p>
<ul>
<li><p>Media type, as specified by <a href="http://tools.ietf.org/html/rfc4288">RFC 4288</a>, such as &quot;application/javascript&quot;. If &quot;&quot;, assumed to be &quot;text/plain;charset=UTF-8&quot;. If media type alone does not specify an unambiguous interpretation of the bytes, clarifying parameters (as the charset of various text types) are REQUIRED.</p>
<p>Alternatively, this may be an absolute IRI describing a type, such as &quot;http://gedcomx.org/date/v1&quot;. Because absolute IRIs always contain a COLON <code>:</code> and media types never contain a COLON, it is unambiguous which form of media type is being specified.</p></li>
<li><p>Language, as specified by <a href="http://tools.ietf.org/html/bcp47">IETF BCP 47</a>; if &quot;&quot;, assumed to be locale-independent (i.e., may be processed using the default locale of the processor).</p></li>
</ul>
</dd>
<dt><strong>reference</strong></dt>
<dd><p>indicating exactly one node within the same dataset. Because they do not span datasets, references may have an implementation-defined format.</p>
<p>The phrase &quot;reference to a <em>X</em>&quot;, where <em>X</em> is Node or one of Node's subtypes, means the reference indicates an element of type <em>X</em> or one of <em>X</em>'s subtypes.</p>
</dd>
<dt><strong>integer</strong></dt>
<dd><p>a signed integer. Every implementations must be able to represent (at least) all integers in the interval [−1, 32767). During serialisation or deserialisation the maximum number of nodes an implementation can handle may be constrained by the largest magnitude integer that the implementation can represent.</p>
</dd>
<dt><strong>regex</strong></dt>
<dd><p>a string containing either (a) a <em>RegularExpressionLiteral</em> or (b) a <em>RegularExpressionBody</em>, both defined in <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5">ECMA 262 section 7.8.5</a>. Because <em>RegularExpressionLiteral</em>s always begin with a SOLIDUS <code>/</code> and <em>RegularExpressionBody</em>s never begin with a SOLIDUS, it is unambiguous which is present in a string. Unlike the ECMA 262 standard, empty regular expressions are allowed. If only a <em>RegularExpressionBody</em> is provided, it is treated as if it had no flags.</p>
<p>Values of type regexs are used in some predicates and producers and behave as documented in <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10">ECMA 262 section 15.10</a>.</p>
</dd>
</dl>
<h2 id="composite-datatypes">Composite Datatypes</h2>
<dl>
<dt><strong>set</strong> of <em>X</em></dt>
<dd><p>(where <em>X</em> is a datatype): an unordered collection of zero or more elements of type <em>X</em>, containing no duplicates.</p>
</dd>
<dt><strong>list</strong> of <em>X</em></dt>
<dd><p>(where <em>X</em> is a datatype): an ordered sequence of zero or more elements of type <em>X</em>, possibly containing duplicates. Given a list of <em>n</em> elements, the first element is identified by the index 0, and each subsequent element by the index (1 + index-of-previous-element).</p>
</dd>
<dt><strong>tuple</strong></dt>
<dd><p>A fixed, ordered group of values, each with a given type. Tuple values may be referenced by index (starting with 0, like a <em>list</em>) or, if the individual elements are given names in the specification, by name. Thus, e.g., the first elements of the tuple of a Property node may be referred to as either the <code>key</code> element or element <code>0</code>.</p>
</dd>
<dt><strong><em>X</em> ↦ <em>Y</em> pair</strong></dt>
<dd><p>A tuple of two elements. If <em>X</em> and <em>Y</em> are types, they specify the types of the elements. Otherwise, <em>X</em> and <em>Y</em> are the names of the elements and types are given elsewhere in the specification text.</p>
</dd>
</dl>
<h2 id="predicate-and-producer-datatypes">Predicate and Producer Datatypes</h2>
<h3 id="predicates">Predicates</h3>
<p>This specification uses the term &quot;<em>X</em> predicate&quot;, where <em>X</em> is a datatype, to mean a function that takes as its parameters</p>
<ul>
<li>a single value (called <em>v</em> in the table below) of type <em>X</em>, and</li>
<li>a list of node tuples (called <em>s</em> in the table below)</li>
</ul>
<p>and returns either <code>true</code> or <code>false</code>.</p>
<p>In this specification, predicates are only evaluated when matching a list of Node Queries against a list of node references; the value of <em>s</em> is created by taking the prefix of that list of node references, up to and including the node reference being matched against the Node Query containing the predicate, and dereferencing each.</p>
<p>Inside a predicate, neither <em>s</em> nor <em>v</em> may be modified and any node references inside tuples inside <em>s</em> are treated as opaque types (i.e., they may not be dereferenced).</p>
<table>
<thead>
<tr class="header">
<th align="left">name</th>
<th align="left">status</th>
<th align="left">types</th>
<th align="left">defined with</th>
<th align="left">returns <code>true</code> when</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Top</td>
<td align="left">REQUIRED</td>
<td align="left">any</td>
<td align="left">(nothing)</td>
<td align="left">always</td>
</tr>
<tr class="even">
<td align="left">Lit</td>
<td align="left">REQUIRED</td>
<td align="left">any</td>
<td align="left"><em>x</em>, a value of the same type as the predicate</td>
<td align="left"><em>v</em> equals <em>x</em></td>
</tr>
<tr class="odd">
<td align="left">Same</td>
<td align="left">RECOMMENDED</td>
<td align="left">any</td>
<td align="left"><em>i</em>, an integer<br/><em>j</em>, an integer</td>
<td align="left"><em>v</em> equals the <em>j</em>th value of the <em>i</em>th tuple in <em>s</em></td>
</tr>
<tr class="even">
<td align="left">Has</td>
<td align="left">RECOMMENDED</td>
<td align="left">set or list of <em>X</em></td>
<td align="left"><em>f</em>, an <em>X</em> predicate</td>
<td align="left"><em>f</em>(<em>e</em>, <em>s</em>) is <code>true</code> for any <em>e</em> in <em>v</em></td>
</tr>
<tr class="odd">
<td align="left">SetHas</td>
<td align="left">RECOMMENDED</td>
<td align="left">set of <em>X</em></td>
<td align="left"><em>x</em>, a set of <em>X</em> predicates</td>
<td align="left">for each <em>f</em> in <em>x</em> there is a <em>e</em> in <em>v</em> such that <em>f</em>(<em>e</em>, <em>s</em>) is <code>true</code></td>
</tr>
<tr class="even">
<td align="left">MapHas</td>
<td align="left">RECOMMENDED</td>
<td align="left">set of string ↦ datum pairs</td>
<td align="left"><em>x</em>, a set of string ↦ (datum predicate) pairs</td>
<td align="left">for each (<em>a</em> ↦ <em>b</em>) in <em>x</em>, there is a (<em>c</em> ↦ <em>d</em>) pair in <em>v</em> such that <em>a</em> = <em>c</em> and <em>b</em>(<em>d</em>) is <code>true</code></td>
</tr>
<tr class="odd">
<td align="left">Cmp</td>
<td align="left">RECOMMENDED</td>
<td align="left">string</td>
<td align="left"><em>∙</em>, an operator from the set {<code>&lt;</code>, <code>≤</code>, <code>=</code>, <code>≠</code>, <code>≥</code>, <code>&gt;</code>}<br/><em>x</em>, a string value</td>
<td align="left"><em>v</em> ∙ <em>x</em> under a lexicographical ordering</td>
</tr>
<tr class="even">
<td align="left">Cmp</td>
<td align="left">OPTIONAL</td>
<td align="left">datum with media type that has defined order</td>
<td align="left"><em>∙</em>, an operator from the set {<code>&lt;</code>, <code>≤</code>, <code>=</code>, <code>≠</code>, <code>≥</code>, <code>&gt;</code>}<br/><em>x</em>, a datum value with the same media type</td>
<td align="left"><em>v</em> ∙ <em>x</em> under that media type's ordering</td>
</tr>
<tr class="odd">
<td align="left">ICmp</td>
<td align="left">OPTIONAL</td>
<td align="left">as <code>Cmp</code></td>
<td align="left"><em>∙</em>, an operator from the set {<code>&lt;</code>, <code>≤</code>, <code>=</code>, <code>≠</code>, <code>≥</code>, <code>&gt;</code>}<br/><em>i</em>, an integer<br/><em>j</em>, an integer</td>
<td align="left">as <code>Cmp</code>, but using the <em>j</em>th value of the <em>i</em>th tuple in <em>s</em> instead of <em>v</em></td>
</tr>
<tr class="even">
<td align="left">Regex</td>
<td align="left">OPTIONAL</td>
<td align="left">string</td>
<td align="left"><em>r</em>, a regex</td>
<td align="left"><em>r</em> matches <em>v</em></td>
</tr>
<tr class="odd">
<td align="left">Len</td>
<td align="left">OPTIONAL</td>
<td align="left">set or list</td>
<td align="left"><em>∙</em>, an operator from the set {<code>&lt;</code>, <code>≤</code>, <code>=</code>, <code>≠</code>, <code>≥</code>, <code>&gt;</code>}<br/><em>x</em>, an integer</td>
<td align="left">((the number of elements in <em>v</em>) ∙ <em>x</em>) is <code>true</code></td>
</tr>
<tr class="even">
<td align="left">And</td>
<td align="left">OPTIONAL</td>
<td align="left">any (call it <em>X</em>)</td>
<td align="left"><em>x</em>, a set of <em>X</em> predicates</td>
<td align="left"><em>f</em>(<em>v</em>, <em>s</em>) is <code>true</code> for all <em>f</em> in <em>x</em></td>
</tr>
<tr class="odd">
<td align="left">Or</td>
<td align="left">OPTIONAL</td>
<td align="left">any (call it <em>X</em>)</td>
<td align="left"><em>x</em>, a set of <em>X</em> predicates</td>
<td align="left"><em>f</em>(<em>v</em>, <em>s</em>) is <code>true</code> for at least one <em>f</em> in <em>x</em></td>
</tr>
<tr class="even">
<td align="left">Not</td>
<td align="left">OPTIONAL</td>
<td align="left">any (call it <em>X</em>)</td>
<td align="left"><em>f</em>, an <em>X</em> predicate</td>
<td align="left"><em>f</em>(<em>v</em>, <em>s</em>) is <code>false</code></td>
</tr>
<tr class="odd">
<td align="left">Script</td>
<td align="left">OPTIONAL</td>
<td align="left">any</td>
<td align="left"><em>x</em>, a datum defining a single function in some programming language</td>
<td align="left">evaluating the function in <em>x</em> with arguments <em>v</em> and <em>s</em> returns <code>true</code></td>
</tr>
</tbody>
</table>
<p>Implementations supporting the <code>Script</code> predicate type SHOULD ensure that all scripts are side-effect-free and return a Boolean value for every input.</p>
<h3 id="producers">Producers</h3>
<p>This specification uses the term &quot;<em>X</em> producer&quot;, where <em>X</em> is a datatype, to mean a function that takes as its parameter a list of node tuples (called <em>s</em> in the table below) and returns a value of type <em>X</em>.</p>
<p>In this specification, producers are only evaluated when evaluating a Node Template in the context of a list of node references; the value of <em>s</em> is created by dereferencing each element of that list.</p>
<p>Inside a producer, <em>s</em> may not be modified and any node references inside tuples inside <em>s</em> are treated as opaque types (i.e., they may not be dereferenced).</p>
<table>
<thead>
<tr class="header">
<th align="left">name</th>
<th align="left">status</th>
<th align="left">types</th>
<th align="left">defined with</th>
<th align="left">returns</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Lit</td>
<td align="left">REQUIRED</td>
<td align="left">any</td>
<td align="left"><em>x</em>, a value</td>
<td align="left"><em>x</em></td>
</tr>
<tr class="even">
<td align="left">Lookup</td>
<td align="left">RECOMMENDED</td>
<td align="left">any</td>
<td align="left"><em>i</em>, an integer<br/><em>j</em>, an integer</td>
<td align="left">the <em>j</em>th value of the <em>i</em>th tuple in <em>s</em></td>
</tr>
<tr class="odd">
<td align="left">Match</td>
<td align="left">OPTIONAL</td>
<td align="left">string</td>
<td align="left"><em>f</em>, a string producer<br/><em>r</em>, a regex<br/><em>i</em>, an integer</td>
<td align="left">the contents of the <em>i</em>th matching group after matching <em>f</em>(<em>s</em>) with <em>r</em>, or the empty string if it does not match or the match has no such group</td>
</tr>
<tr class="even">
<td align="left">Slice</td>
<td align="left">OPTIONAL</td>
<td align="left">string or list</td>
<td align="left"><em>f</em>, a string or list producer<br/><em>i</em>, an integer<br/><em>j</em>, an integer</td>
<td align="left">the zero-indexed subsequence of <em>f</em>(<em>s</em>) from <em>i</em> (inclusive) to <em>j</em> (exclusive)<br/>negative indices have the length of the sequence added to them before dereferencing<br/>out-of-bounds indices are clamped to bounds<br/>negative-width subsequences return the empty sequence</td>
</tr>
<tr class="odd">
<td align="left">Cat</td>
<td align="left">OPTIONAL</td>
<td align="left">string or list</td>
<td align="left"><em>x</em>, a list of string or list producers</td>
<td align="left">the sequence produced by concatenating the sequenced returned by each elements of <em>x</em> in order</td>
</tr>
<tr class="even">
<td align="left">Union</td>
<td align="left">OPTIONAL</td>
<td align="left">set</td>
<td align="left"><em>x</em>, a set of set producers</td>
<td align="left">a set containing every value contained in any of the sets produced by each of the elements of <em>x</em></td>
</tr>
<tr class="odd">
<td align="left">Intersect</td>
<td align="left">OPTIONAL</td>
<td align="left">set</td>
<td align="left"><em>x</em>, a set of set producers</td>
<td align="left">a set containing those values that are in every set produced by each element of <em>x</em></td>
</tr>
<tr class="even">
<td align="left">Script</td>
<td align="left">OPTIONAL</td>
<td align="left">any</td>
<td align="left"><em>x</em>, a datum defining a single function in some programming language</td>
<td align="left">the value returned when evaluating the function in <em>x</em> with argument <em>s</em></td>
</tr>
</tbody>
</table>
<p>Implementations supporting the <code>Script</code> predicate type SHOULD ensure that all scripts are side-effect-free and return a value of the appropriate type for every input.</p>
<h2 id="the-nine-node-types">The Nine Node Types</h2>
<p>Reasoning is a set of nodes. Node types are expressed in the following hierarchy:</p>
<ul>
<li><p>Node</p>
<ul>
<li><p>Claim</p>
<ul>
<li><p>Subject</p>
<p>A tuple <code>(slug, source)</code>, where</p>
<ul>
<li><code>slug</code> is a datum used to uniquely identify a single subject discussed by a source.</li>
<li><code>source</code> is a reference to a Source</li>
</ul></li>
<li><p>Property</p>
<p>A tuple <code>(key, of, value, source)</code>, where</p>
<ul>
<li><code>key</code> is a string</li>
<li><code>of</code> is a reference to a Node</li>
<li><code>value</code> is a datum</li>
<li><code>source</code> is a reference to a Source</li>
</ul></li>
<li><p>Connection</p>
<p>A tuple <code>(key, of, value, source)</code>, where</p>
<ul>
<li><code>key</code> is a string</li>
<li><code>of</code> is a reference to a Node</li>
<li><code>value</code> is a reference to a Node</li>
<li><code>source</code> is a reference to a Source</li>
</ul></li>
<li><p>Tag</p>
<p>A tuple <code>(key, of, source)</code>, where</p>
<ul>
<li><code>key</code> is a string</li>
<li><code>of</code> is a nonempty set of references to Nodes</li>
<li><code>source</code> is a reference to a Source</li>
</ul>
<p>Some <code>key</code>s impose restrictions on the <code>of</code> set:</p>
<ul>
<li><code>key</code>s &quot;same&quot; and &quot;distinct&quot; require sets of cardinality ≥ 2.</li>
<li><code>key</code> &quot;misinterpreted&quot; requires a set of cardinality = 1 and that the node referenced in the set be a Claim.</li>
<li><code>key</code> &quot;wrong&quot; may neither reference a Subject nor another &quot;wrong&quot; Tag in the <code>of</code>, unless also including the <code>source</code> of that Claim.</li>
<li>if <code>key</code> &quot;wrong&quot; references another &quot;wrong&quot; Tag, it may not also reference anything referenced by that referenced &quot;wrong&quot; Tag.</li>
<li><code>key</code> &quot;wrong&quot; may not reference an Aggregated Subject or an OutRef.</li>
</ul></li>
</ul></li>
<li><p>Aggregated Subject</p>
<p>A singleton tuple <code>(parts)</code>, where</p>
<ul>
<li><code>parts</code> is a references to a Tag node with <code>key</code> &quot;same&quot; and only Subject and/or Aggregated Subject nodes referenced by its <code>of</code>.</li>
</ul></li>
<li><p>Source</p>
<ul>
<li><p>OutRef</p>
<p>A tuple <code>(partOf, details)</code>, where</p>
<ul>
<li><code>partOf</code> is a (possibly empty) set of references to OutRefs</li>
<li><code>details</code> is a set of string ↦ datum pairs</li>
</ul></li>
<li><p>Derivation</p>
<p>A tuple <code>(support, reason)</code>, where</p>
<ul>
<li><code>support</code> is a non-empty set of references to Claims</li>
<li><code>reason</code> is a string</li>
</ul></li>
<li><p>Inference</p>
<p>A tuple <code>(support, reason)</code>, where</p>
<ul>
<li><code>support</code> is an list of references to nodes</li>
<li><code>reason</code> is a reference to an Expectation</li>
</ul>
<p>It must be the case that the <code>support</code> matches the <code>antecedent</code> of the <code>reason</code>.</p></li>
</ul></li>
<li><p>Expectation</p>
<p>A tuple <code>(antecedent, consequent)</code>, where</p>
<ul>
<li><code>antecedent</code> is an list of Node Queries</li>
<li><code>consequent</code> is an list of Node Templates</li>
</ul>
<p>A Node Query may be any Node except that</p>
<ul>
<li><p>In place of any value of non-reference type <em>X</em>, the Node Query has an <em>X</em> predicate.</p></li>
<li><p>In place of any value of reference type <em>X</em>, the Node Query must have either the special value <code>-1</code> or a non-negative integer <em>i</em> such that the <em>i</em>th node in the <code>antecedent</code> is of a type that may be referenced by <em>X</em> and <em>i</em> is strictly smaller than the index of the Node Query that contains it.</p></li>
</ul>
<p>A Node Template may be any Claim except that</p>
<ul>
<li><p>It has the special value <code>-1</code> as its <code>source</code></p></li>
<li><p>In place of any value of non-reference type <em>X</em>, the Node Template has an <em>X</em> producer.</p></li>
<li><p>In place of any value of reference type <em>X</em>, the Node Query must have a non-negative integer <em>i</em> such that both (1) the <em>i</em>th node in the list created by concatenating <code>antecedent</code> and <code>consequent</code> is of a type that may be referenced by <em>X</em> and (2) <em>i</em> is strictly smaller than the index of the Node Template that contains it in that concatenate list.</p></li>
</ul></li>
</ul></li>
</ul>
<h2 id="definitions-and-constraints">Definitions and Constraints</h2>
<h3 id="dependencies-and-cycles">Dependencies and Cycles</h3>
<p>The <strong>dependencies</strong> of a node is defined to be the set of all nodes that the node references unioned with all of those nodes' dependencies, recursively.</p>
<p>It is REQUIRED that all references be acyclic; in other words, no node may be included in its own dependencies.</p>
<h3 id="equality">Equality</h3>
<p>Node and value <strong>equality</strong> is defined as follows:</p>
<ul>
<li><p>Two nodes are equal if and only if both (1) they are the same type of node and (2) each field of one node is equal to the corresponding field of the other node.</p></li>
<li><p>Two references are equal if and only if they refer to nodes that are equal.</p></li>
<li><p>Two sets are equal if and only if each element in each set has an equal element in the other set.</p></li>
<li><p>Two lists are equal if and only if both (1) they have the same length and (2) for each valid index for the lists, the elements in both lists at that index are equal.</p></li>
<li><p>Two predicates are equal if they have the same type and are defined with equal values. They are not equal if there exists some inputs for which they give different results. If they are defined differently but give the same result for all inputs, their equality is not specified by this specification.</p></li>
<li><p>Two producers are equal if they have the same type and are defined with equal values. They are not equal if there exists some inputs for which they give non-equal results. If they are defined differently but give equal result for all inputs, their equality is not specified by this specification.</p></li>
<li><p>Two strings are equal if they contain the same conceptual characters in the same order.</p></li>
<li><p>Two data are equal if and only if either (1) there is an official notion of eqaulity for the given media type(s) and the blobs are equal under than definition or (2) the media types are equal and the blobs have the same bytes in the same order.</p></li>
</ul>
<h3 id="constituents">Constituents</h3>
<p>The <strong>constituents</strong> of any node <em>except</em> an Aggregated Subject node is defined to be the singleton set containing just that Node itself.</p>
<p>The <strong>constituents</strong> of an Aggregated Subject node is defined to be the singleton set containing the Aggregated Subject node itself and the elements of the <strong>constituents</strong> of each of the nodes referenced in the <code>of</code> field of the node referenced by the Aggregated Subject's <code>parts</code> field.</p>
<h3 id="matching">Matching</h3>
<p>Node and value <strong>matching</strong> is defined as follows:</p>
<ul>
<li><p>A predicate and a value match if all of the following are true:</p>
<ol>
<li>the matching is occurring within the context of matching a list of Node Queries and a list of node references</li>
<li>the value has a type that allows the predicate to be evaluated using the value and the list of node tuples created from the list of node references, as described in the section <a href="#producers">Producers</a></li>
<li>evaluating the predicate with the value and the list of tuples yields the value <code>true</code></li>
</ol>
<p>Optionally, if the predicate does not utilise its list of tuples parameter then the predicate may be said to match if condition 3 alone would be true for any list of tuples supplied.</p></li>
<li><p>The special value <code>-1</code> matches any node reference.</p></li>
<li><p>A set of integers matches a set of node references if each integer in the set of integers matches some node reference in the set of node references.</p></li>
<li><p>A non-negative integer <em>i</em> matches a node reference <em>r</em> if and only if all of the following are true:</p>
<ol>
<li>there is a list of node references that was used to initiate the matching process</li>
<li>there is an element of that list at index <em>i</em></li>
<li>the node referenced by the element at the index <em>i</em> is a constituent of <em>r</em>.</li>
</ol></li>
<li><p>A list of node references matches a list of Node Queries if and only if both (1) they have the same length and (2) for each valid list index for the lists, the elements in the list of node reference at that index matches the element in the list of Node Queries at that index.</p></li>
<li><p>A node reference matches a Node Query if and only if both (1) the referenced node and the Node Query are of the same node type and (2) each field in the referenced node matches the corresponding node in the Node Query.</p></li>
<li><p>A string matches a regex if and only if the algorithm outlined in <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.10.6.3">ECMA 262 section 15.10.6.3</a> would return <code>true</code>.</p></li>
</ul>
<h3 id="instantiating-nodes-from-inferences">Instantiating Nodes from Inferences</h3>
<p>The <strong>instantiated node list</strong> of an Inference is defined to be a list of Nodes having the same length as the <code>consequent</code> of the <code>reason</code> of the Inference such that the Node at index <em>i</em> of the instantiated node list is created from the Node Template at index <em>i</em> of the <code>consequent</code> by doing all of the following (in any order)</p>
<ul>
<li><p>replacing any producer values with the result of applying that function using the <code>antecedent</code> of the Inference as the function's argument.</p></li>
<li><p>replacing the <code>source</code> value (which is <code>-1</code> in Node Templates) with a reference to the Inference.</p></li>
<li><p>replacing any non-negative integers with the node reference in the <code>support</code> list at the integer's index if the integer is smaller than the length of the <code>support</code> list; otherwise with a reference to the node at index <em>i</em>−<em>x</em> of the instantiated node list being constructed, where <em>x</em> is the length of the <code>support</code> list.</p></li>
</ul>
<p>A Claim may only reference an Inference in its <code>source</code> field if it is an element of the instantiated node list of that Inference.</p>
<h1 id="partial-implementation-and-extension">Partial Implementation and Extension</h1>
<p>For various reasons, implementers should expect to interact with other software that has adopted only portions of this specification and that have extended this specification in various ways. This section discusses appropriate ways to interact with partial implementations and extensions.</p>
<h2 id="policies-and-suggestions">Policies and Suggestions</h2>
<p>The set of elements in each node type is fixed, and MUST NOT be extended or reduced.</p>
<p>The set of node types MAY be extended, though it is RECOMMENDED that extensions be handled with custom <code>key</code>s in Properties, Connections, and/or Tags instead. It is RECOMMENDED that software ignore new node types when receiving extended data.</p>
<h3 id="partial-implementations-and-data-reductions">Partial implementations and data reductions</h3>
<h4 id="removing-unwanted-or-private-information">Removing unwanted or private information</h4>
<p>Software MAY chose to ignore any node or set of nodes when receiving a dataset provided that all nodes that depend upon the ignored node(s) are also ignored.</p>
<p>Software MAY chose to omit any node or set of nodes while sending a dataset provided that all nodes that depend upon the omitted node(s) are also omitted.</p>
<h4 id="removing-expectations-and-inferences">Removing Expectations and Inferences</h4>
<p>Software sending/receiving a dataset MAY chose to omit/ignore all Inferences and Expectations by converting each Inference into a Derivation with the same <code>support</code> as the Inference and a textual representation of the Expectation as the <code>reason</code>. If the software is unable to convert the Expectation to text, it SHOULD use the text &quot;(reasoning omitted)&quot;, or equivalent text in another language, as the <code>reason</code>.</p>
<h4 id="removing-all-reasoning">Removing all reasoning</h4>
<p>Software sending/receiving a dataset MAY chose to omit/ignore all reasoning, reducing the dataset to a &quot;belief snapshot&quot;. Belief snapshots are valid datasets under this specification with the following additional constraints:</p>
<ul>
<li>Only five node types are used: Subject, Property, Connection, Derivation, and OutRef</li>
<li>Each Claim's <code>source</code> is a Derivation</li>
<li>Each element of a Derivation's <code>support</code> is an OutRef</li>
</ul>
<p>General datasets may be reduced to a belief snapshot via the following process:</p>
<ol>
<li>Create a Subject for each group of Subjects and Aggregated Subjects linked by &quot;same&quot; Tags. The new Subject's <code>source</code> should be a Derivation whose <code>support</code> is the set of all OutRef nodes in any of the original nodes' dependencies.</li>
<li>Copy all Properties and Connections that pointed to any of the the original nodes to point to the new node. The new Properties' and Connections' <code>source</code>s should be Derivations whose <code>support</code>s are the sets of all OutRef nodes in any of the original nodes' dependencies.</li>
<li>Replacing any set of Properties or Connections that differ only in <code>source</code> with a single node having as its <code>source</code> a Derivation with the union of the original claims' <code>source</code>s' <code>support</code> as the new Derivation's <code>support</code>.</li>
</ol>
<h3 id="handling-unsupported-values">Handling Unsupported Values</h3>
<h4 id="optional-predicates-and-producers">Optional predicates and producers</h4>
<p>When software that supports Expectation nodes receives a dataset including Expectations that contain predicates that the receiving software cannot evaluate, it is RECOMMENDED that the recieving software keep the Expectation as received but treat the extra predicate as being equivalent to <em>Top</em> when error-checking received data and as equivalent to <em>Not</em>(<em>Top</em>) when deciding if the user can create new Inferences based on the Expectation.</p>
<p>When software that supports Expectation nodes receives a dataset including Expectations that contain producers that the receiving software cannot evaluate, it is RECOMMENDED that the receiving software keep the Expectation as received but treat them as unchecked (like a Derivation).</p>
<h4 id="constrained-vocabularies">Constrained vocabularies</h4>
<p>If software desires a particular set of keys in its data, it is RECOMMENDED that a set of term-normalising Expectations be used to automatically create new Inferences and normalised terms upon receipt of new datasets, keeping the pre-normalised terms as <code>support</code> for the Inferences.</p>
<p>For software not supporting Expectations, it is RECOMMENDED that Derivations be used, resulting in a dataset equivalent to creating the Expectations and Inferences and then applying the process outlined in <a href="#removing-expectations-and-inferences">Removing Expectations and Inferences</a>. For software not supporting any reasoning, it is RECOMMENDED that the resulting dataset be equivalent to creating the Expectations and Inferences and then applying the process outlined in <a href="#removing-all-reasoning">Removing all reasoning</a>.</p>
<p>If the software does not know how to normalise a particular term, or does but does not care to represent the resulting normalised term, it MAY omit the term and its containing node, as outlined in <a href="#removing-unwanted-or-private-information">Removing unwanted or private information</a>.</p>
<h4 id="constrained-representations-and-topics">Constrained representations and topics</h4>
<p>If software desires a particular structure in its data, for example desiring birthdate Properties instead of birth Subjects, it is RECOMMENDED that a set of Expectations be used to automatically create new Inferences and normalised structures upon receipt of new datasets.</p>
<p>In some cases, software may decide to discard additional nodes; for example, software that tracks human relationships might chose to omit not only a &quot;species&quot;:&quot;horse&quot; Property but also the Subject to which it is attached and all other claims <code>of</code> that Subject.</p>
<h1 id="discussion">Discussion</h1>
<h2 id="node-identity-and-redundancy">Node Identity and Redundancy</h2>
<p>Node identity is determined only by the node's contents. There is no notion of durable URI, UUID, GUID, or other unique, durable identifier for a node in this specification, nor should one be introduced unless that identifier can be uniquely determined from the contents of the node alone, as for example a hash-based UUID.</p>
<p>Because node contents determine node identity, there is no intrinsic notion of versions of a node, nor of updating or editing its contents. The concept that one node is an update of another should be expressed using a Connection with <code>key</code> &quot;update&quot;.</p>
<p>Because node identity is determined only by content, discarding nodes does not impede collaboration; returning the kept subsets with any new nodes to the originator allows the originator to add the new nodes to their existing set, potentially without even realising that some of the nodes sent were not returned.</p>
<p>The some of the practices for removing information outlined in <a href="#partial-implementations-and-data-reductions">Partial implementations and data reductions</a> can replace nodes or introduce new nodes containing information that is redundant with previous data. Replacement doesn't actually modify or destroy any existing nodes: they are values and if the sender of data does not chose to discard them they cannot be modified or destroyed by the recipient. When the recipient sends back data, it may contain new derivative nodes; however, the information in these nodes, while redundant, is not new. Keeping these redundant nodes around does not impede research provided that the user interface prevents redundant information from distracting the user. If nodes are clearly redundant, the originator's software could also omit them upon receipt of the redundant data.</p>
<h2 id="term-normalisation">Term Normalisation</h2>
<p>When extracting the contents of an external source as a set of Claim nodes citing the OutRef of the external source, there is a quality-of-use expectation that the <code>slug</code> of each Subject be a description (in any language) of some specific part of the source that references the Subject in question; and that the various Properties and Connections reflect, as closely as possible, the language of the source (e.g., using a Connection with key <code>Papa</code> if that is the wording used to describe the relationship in the source).</p>
<p>Term normalisation should then happen by introducing new, normalised-term properties and connections <code>source</code>d to either Inference or Derivation nodes that use the non-normalised terms as (part of) their <code>support</code>. In many cases, the <code>support</code> should also include some contextual information such as the date, location, and/or language of the underlying document.</p>
<h2 id="inferences-vs.-derivations-and-the-creation-of-expectations">Inferences vs. Derivations, and the creation of Expectations</h2>
<p>Inferences and Derivations are both intended to fulfil the same objective: to represent the fact that some claims were constructed using other pieces of information.</p>
<p>The Derivation node is flexible and does not require the relatively complicated support for matches and predicates and producers, etc., which Inferences do require. However, they leave the <code>reason</code> in machine-opaque human-language text, which means that they are not readily analysed by the computer, are language-dependent, may lack necessary detail or contain text not in keeping with their support, etc.</p>
<p>The Inference node, on the other hand, is a purely machine-understandable representation of reasoning. Like a Derivation, an Inference is flexible enough to be created for any finite-support inference. However, Inferences require the creation of Expectation nodes.</p>
<p>Sophisticated Expectation nodes are possible, particularly with <code>Script</code>-type predicates and producers, but many Expectations can be readily created using the following interactive process:</p>
<ol>
<li><p>Have the user specify the nodes they intend to infer and select the nodes they recognise as the support for their inference. This step would be done for Derivation nodes as well...</p></li>
<li><p>Build a set of candidate antecedents from the nodes they identified as support augmented with any nodes referenced by the nodes the user identified as being inferred that are not already in the <code>antecedent</code> or inferred collections.</p></li>
<li><p>For each field of each candidate antecedent, ask the user &quot;is this field important to your reasoning?&quot; If the answer is &quot;no&quot;, replace the field with <code>-1</code> (if a node reference) or <em>Top</em> (otherwise). If the answer is &quot;yes&quot;, add the referenced node to the candidate antecedent set (if a node reference) or replace it with a <em>Lit</em> (otherwise). Continue until you have asked about all nodes of all fields in the antecedent set.</p>
<p>You could optionally ask additional questions, such as &quot;we notice that these two nodes both have the same <code>value</code>; is that same-value characteristic important?&quot;, to help build more advanced predicates, if you so desire.</p></li>
<li><p>Organise the candidate antecedents such that, if node <em>A</em> is in node <em>B</em>'s dependencies and both are antecedents then <em>A</em> appears before <em>B</em>. Use this ordering to populate the <code>antecedent</code> list and to replace node references with integers.</p></li>
<li><p>Organise the inferred nodes such that, if node <em>A</em> is in node <em>B</em>'s dependencies and both are being inferred then <em>A</em> appears before <em>B</em>. Use this ordering to populate the <code>consequent</code> list and to replace node references with integers. Additionally, replace all inferred node <code>source</code> values with <code>-1</code>, as required by the definition of Node Template.</p></li>
</ol>
</body>
</html>
