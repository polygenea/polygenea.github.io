<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Representation of Reasoning - alpha draft 2</title>
    <style type="text/css">
    body{font-family:sans-serif; counter-reset:h1;}
    code{font-family:monospace;font-size:100%;background-color:#eee;border:1px solid #aaa; padding:1px; border-radius:4px;}
    table{border-collapse:collapse;}
    tr:nth-child(2n){background-color:#ddd;}
    td,th{padding:0.25ex 1ex;}
    th{border-bottom:1px solid black;}
    h1:before { content: counter(h1) ". "; counter-increment: h1; }
    h1 {counter-reset:h2;}
    h2:before { content: counter(h1) "." counter(h2) ". "; counter-increment: h2; }
    h2 {counter-reset: h3;}
    h3:before { content: counter(h1) "." counter(h2) "." counter(h3) ". "; counter-increment: h3; }
    h3 {counter-reset: h4;}
    h4:before { content: counter(h1) "." counter(h2) "." counter(h3) "." counter(h4) ". "; counter-increment: h4; }
    h4 {counter-reset: h5;}
    code{white-space: pre;}
    pre code{border:none; background:none}
    pre{display:table; border:1px solid #aaa; padding:4px; border-radius:6px; background-color:#eee}
    </style>
</head>
<body>

<div style="text-align:right;"><p>All contents of this page are original work by:<br/>Luther Tychonievich</p><p>Posted 2015-06-17<br/>released into the <a href="https://creativecommons.org/publicdomain/zero/1.0/">public domain</a></p></div>

<p>This is an alpha version of a specification of a model for representing family history and genealogical research.</p>
<p>The central goal of this model is the representation of reasoning processes, as realised by the Inference, Derivation, and Expectation node types. A secondary goal is to ensure, at a data model level, that it is impossible to have two communicating parties think they understand one another when in fact they have different versions of some element of their shared universe of discourse. To reach these goals, the model uses a representation of beliefs about the past that somewhat resembles <a href="http://www.w3.org/TR/rdf11-concepts/">RDF</a>, in that information about a given entity is stored outside of the entity. Unlike RDF, each of these Claim elements has a source, representing where it came from; the structure and presence of these sources is key to achieving the central goal of this model. Additionally, Claims and other elements are defined not to have identity (a.k.a, they are compare-by-value, bit-copiable, identity=value, immutable, etc.); by definition, changing the contents of any element actually creates a new element, leaving the old one present and unchanged. The notion that a different element is intended as an update of another element is itself a claim made during reasoning and represented as such in this model.</p>
<p>This document is an alpha release intended to present a self-consistent and fairly complete specification that can be used to understand how the various conceptual pieces of this approach could fit together and to form a starting point for discussions of this approach. Many times while writing this document the optimal choice was not evident; rather than list each of these decision points, this document simply makes decisions so that the presentation can hold together as a whole, optimal or not.</p>
<h1 id="representation-of-reasoning">Representation of Reasoning</h1>
<h2 id="basic-datatypes">Basic Datatypes</h2>
<dl>
<dt><strong>character</strong></dt>
<dd><p>an atomic unit of text as specified by <code>ISO/IEC 10646</code>.</p>
</dd>
<dt><strong>string</strong></dt>
<dd><p>a finite-length sequence of characters.</p>
</dd>
<dt><strong>octet</strong></dt>
<dd><p>a sequence of eight bits, each either 0 or 1.</p>
</dd>
<dt><strong>blob</strong></dt>
<dd><p>a finite-length sequence of octets.</p>
</dd>
<dt><strong>datum</strong></dt>
<dd><p>a paired media type and payload.</p>
<p>Media types may be specified by <a href="http://tools.ietf.org/html/rfc4288">RFC 4288</a> (e.g., <code>text/javascript</code>) or represented by an IRI (e.g., <code>http://gedcomx.org/date/v1</code>). Because absolute IRIs always contain a COLON <code>:</code> and media types never contain a COLON, it is unambiguous which form of media type is being specified.</p>
<p>Payload is typically a blob, but may be a string for some media types.</p>
</dd>
<dt><strong>reference</strong></dt>
<dd><p>indicating exactly one node within the same dataset. Because they do not span datasets, references may have an implementation-defined format.</p>
<p>The phrase &quot;reference to a <em>X</em>&quot;, where <em>X</em> is Node or one of Node's subtypes, means the reference indicates an element of type <em>X</em> or one of <em>X</em>'s subtypes.</p>
</dd>
<dt><strong>integer</strong></dt>
<dd><p>a signed integer. Every implementations must be able to represent (at least) all integers in the interval between −1 and 32766, inclusive. During serialisation or deserialisation the maximum number of nodes an implementation can handle may be constrained by the largest magnitude integer that the implementation can represent.</p>
</dd>
</dl>
<h2 id="composite-datatypes">Composite Datatypes</h2>
<dl>
<dt><strong>set</strong> of <em>X</em></dt>
<dd><p>(where <em>X</em> is a datatype): an unordered collection of zero or more elements of type <em>X</em>, containing no duplicates.</p>
</dd>
<dt><strong>list</strong> of <em>X</em></dt>
<dd><p>(where <em>X</em> is a datatype): an ordered sequence of zero or more elements of type <em>X</em>, possibly containing duplicates. Given a list of <em>n</em> elements, the first element is identified by the index 0, and each subsequent element by the index (1 + index-of-previous-element).</p>
</dd>
<dt><strong>tuple</strong></dt>
<dd><p>A fixed, ordered group of values, each with a given type. Tuple values may be referenced by index (starting with 0, like a <em>list</em>) or, if the individual elements are given names in the specification, by name. Thus, e.g., the first elements of the tuple of a Property node may be referred to as either the <code>key</code> element or element <code>0</code>.</p>
</dd>
<dt><strong><em>X</em> ↦ <em>Y</em> pair</strong></dt>
<dd><p>A tuple of two elements. If <em>X</em> and <em>Y</em> are types, they specify the types of the elements. Otherwise, <em>X</em> and <em>Y</em> are the names of the elements and types are given elsewhere in the specification text.</p>
</dd>
</dl>
<h2 id="the-eight-node-types">The Eight Node Types</h2>
<p>This specification defines several concrete types. These form a type hierarchy:</p>
<ul>
<li>Node
<ul>
<li>Claim
<ul>
<li>Subject: identifying a single (subject of discussion, source discussing it) pair</li>
<li>Property: a single piece of information about a node</li>
<li>Connection: a directed connection between two nodes</li>
</ul></li>
<li>Source
<ul>
<li>OutRef: identifying some information source external to this specification</li>
<li>Derivation: a free-text description of a step in the reasoning processes</li>
<li>Inference: a structured description of a step in the reasoning processes</li>
</ul></li>
<li>Aggregated Subject: a single subject inferred to be discussed by many source</li>
<li>Expectation: structured descriptions of trends, inference rules, and external knowledge</li>
</ul></li>
</ul>
<p>For each Node type there is a Node Query type, with the exception that Subject and Aggregated Subject nodes share a single Node Query type. Node Queries are used to structure the preconditions or antecedents of an Expectation.</p>
<p>For each Claim type there is a Node Template type. Node Templates are used to structure the postconditions or consequent of an Expectation.</p>
<p>Each type is described in terms of its constituent fields; each field is given both an index and a name. Indices are used to create tuples from nodes and streamline the presentation of aspects of the specification that are not dependent on the particular node types; names are when discussing particular nodes because they are more suggestive of the purpose of the various fields.</p>
<p>By design, each field name corresponds to the same index everywhere it appears. To achieve that end, each Node Template has a dummy <code>source</code> field (index 0, always value <code>-1</code>).</p>
<h3 id="nodes">Nodes</h3>
<table>
<thead>
<tr class="header">
<th align="left">Node subtype</th>
<th align="left">is a</th>
<th align="left">Properties (index. name : type)</th>
<th align="left">Constraints</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Aggregated Subject</td>
<td align="left"></td>
<td align="left">0. <code>parts</code> : reference to a Tag</td>
<td align="left"><code>parts</code>'s <code>key</code> MUST be &quot;same&quot;</td>
</tr>
<tr class="even">
<td align="left">Connection</td>
<td align="left">Claim</td>
<td align="left">0. <code>source</code> : reference to a Source<br/>1. <code>key</code> : string <br/>2. <code>of</code> : reference to a Node<br/>3. <code>value</code> : int</td>
<td align="left">some <code>key</code>s make constraints on <code>of</code> and/or <code>value</code></td>
</tr>
<tr class="odd">
<td align="left">Derivation</td>
<td align="left">Source</td>
<td align="left">0. <code>support</code> : set of references to Nodes<br/>1. <code>reason</code> : string</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">Expectation</td>
<td align="left"></td>
<td align="left">0. <code>antecedent</code> : list of Node Queries<br/>1. <code>consequent</code> : list of Node Templates</td>
<td align="left"><em>See below</em></td>
</tr>
<tr class="odd">
<td align="left">Inference</td>
<td align="left">Source</td>
<td align="left">0. <code>support</code> : list of references to Nodes<br/>1. <code>reason</code> : reference to an Expectation</td>
<td align="left"><code>reason</code>'s <code>antecedent</code> SHOULD <a href="#matching">match</a> <code>support</code><br/><em>See below</em></td>
</tr>
<tr class="even">
<td align="left">OutRef</td>
<td align="left">Source</td>
<td align="left">0. <code>parents</code> : set of (string ↦ reference to an OutRef) pairs<br/>1. <code>details</code> : set of (string ↦ datum) pairs</td>
<td align="left">some string values make constraints on their corresponding reference or datum values</td>
</tr>
<tr class="odd">
<td align="left">Property</td>
<td align="left">Claim</td>
<td align="left">0. <code>source</code> : reference to a Source<br/>1. <code>key</code> : string <br/>2. <code>of</code> : reference to a Node<br/>3. <code>value</code> : datum</td>
<td align="left">some <code>key</code>s make constraints on <code>of</code> and/or <code>value</code></td>
</tr>
<tr class="even">
<td align="left">Subject</td>
<td align="left">Claim</td>
<td align="left">0. <code>source</code> : reference to a Source<br/>1. <code>slug</code> : string</td>
<td align="left"><code>slug</code> SHOULD identify a single subject within the source</td>
</tr>
<tr class="odd">
<td align="left">Tag</td>
<td align="left">Claim</td>
<td align="left">0. <code>source</code> : reference to a Source<br/>1. <code>key</code> : string <br/>2. <code>of</code> : set of references to Nodes</td>
<td align="left">some <code>key</code>s make constraints on <code>of</code></td>
</tr>
</tbody>
</table>
<p>All references MUST be acyclic and MUST refer to another node in the same dataset. If some user insists some Claim has no source, it is RECOMMENDED that the <code>source</code> reference an OutRef with <code>details</code> including (&quot;type&quot; ↦ &quot;user assertion&quot;) and (&quot;user&quot; ↦ however the user is identified).</p>
<p>A Claim SHOULD NOT reference an Inference in its <code>source</code> field UNLESS it is an element of the <a href="#instantiating-nodes-from-inferences">instantiated node list</a> of that Inference.</p>
<p>Some constraints on Node Queries and Node Templates involve their containing Expectation, and can be seen as constraints on Expectations.</p>
<p>All nodes that could be <a href="#instantiating-nodes-from-inferences">instantiated from an Inference</a> MUST satisfy any constraints that apply to other nodes of that type. Implementations SHOULD enforce these constraints during Expectation and Node Template construction, but MAY delay enforcement until Inference construction instead.</p>
<h3 id="node-queries">Node Queries</h3>
<p>For each node type <em>X</em> (excepting Aggregated Subject), there is a corresponding node query type <em>X</em> Query, which differs from the <em>X</em> node type as follows:</p>
<ul>
<li>where <em>X</em> has a &quot;reference to a <em>Y</em>&quot;, <em>X</em> Query has an integer</li>
<li>where <em>X</em> has a &quot;string&quot;, <em>X</em> Query has a string predicate, which is one of
<ul>
<li><strong>Top</strong>, a special value meaning &quot;matches anything&quot;</li>
<li>a string, matching only what it equals</li>
<li>a datum with media type <code>application/javascript</code>; see <a href="#matching">Matching</a> below for details</li>
</ul></li>
<li>where <em>X</em> has a &quot;datum&quot;, <em>X</em> Query has a datum predicate, which is one of
<ul>
<li><strong>Top</strong>, a special value meaning &quot;matches anything&quot;</li>
<li>a datum, matching only what it equals</li>
<li>a datum with media type <code>application/javascript</code>; see <a href="#matching">Matching</a> below for details</li>
</ul></li>
</ul>
<h3 id="node-templates">Node Templates</h3>
<p>For each claim node type <em>X</em> there is a corresponding node template type <em>X</em> Template, which differs from the <em>X</em> node type as follows:</p>
<ul>
<li>field 0. <code>source</code> always has the value −1</li>
<li>where <em>X</em> has a &quot;reference to a <em>Y</em>&quot; (other than <code>source</code>), <em>X</em> Template has an integer</li>
<li>where <em>X</em> has a &quot;string&quot;, <em>X</em> Template has a string producer, which is one of
<ul>
<li>a string, producing only itself</li>
<li>a datum with media type <code>application/javascript</code>; see <a href="#instantiating-nodes-from-inferences">Instantiating Nodes from Inferences</a> below for details</li>
</ul></li>
<li>where <em>X</em> has a &quot;datum&quot;, <em>X</em> Template has a datum producer, which is one of
<ul>
<li>a datum, producing only itself</li>
<li>a datum with media type <code>application/javascript</code>; see <a href="#instantiating-nodes-from-inferences">Instantiating Nodes from Inferences</a> below for details</li>
</ul></li>
</ul>
<h2 id="definitions-and-constraints">Definitions and Constraints</h2>
<p>A set of nodes is called a <strong>dataset</strong>. This specification only discusses complete datasets, where all node references are to other nodes within the dataset. Communication protocols that communicate via partial datasets are neither forbidden by this specification nor discussed by it.</p>
<h3 id="dependencies-and-cycles">Dependencies and Cycles</h3>
<p>The <strong>dependencies</strong> of a node is defined to be the set of all nodes that the node references unioned with all of those nodes' dependencies, recursively.</p>
<p>It is REQUIRED that all references be acyclic; in other words, no node may be included in its own dependencies.</p>
<h3 id="equality">Equality</h3>
<p>Node and value <strong>equality</strong> is defined as follows:</p>
<ul>
<li><p>Two nodes are equal if and only if both (1) they are the same type of node (or one is an Expectation Query and the other an Expectation), and (2) each field of one node is equal to the corresponding field of the other node.</p></li>
<li><p>Two references are equal if and only if they refer to nodes that are equal.</p></li>
<li><p>Two sets are equal if and only if each element in each set has an equal element in the other set.</p></li>
<li><p>Two lists are equal if and only if both (1) they have the same length and (2) for each valid index for the lists, the elements in both lists at that index are equal.</p></li>
<li><p>Two strings are equal if they contain the same characters in the same order. Looser versions of equality using unicode normalized forms are also permitted, though not required by this specification.</p></li>
<li><p>Two data are equal if the media types are equal and the payloads are equal. Looser versions of media-type-specific equality are also permitted, though not required by this specification.</p></li>
</ul>
<h3 id="constituents">Constituents</h3>
<p>The <strong>constituents</strong> of any node that is not an Aggregated Subject node is defined to be the singleton set containing just that Node itself.</p>
<p>The <strong>constituents</strong> of an Aggregated Subject node is defined to be the set containing the Aggregated Subject node itself and the elements of the <em>constituents</em> of each of the nodes referenced in the <code>of</code> field of the node referenced by the Aggregated Subject's <code>parts</code> field.</p>
<h3 id="matching">Matching</h3>
<p>Node and value <strong>matching</strong> is defined as follows:</p>
<ul>
<li><p>The <strong>Top</strong> predicate matches any value</p></li>
<li><p>A literal predicate and a value match if they are equal</p></li>
<li><p>A <code>application/javascript</code> predicate and a value match if the following process yields the value <code>true</code>:</p>
<ol>
<li>create a javascript evaluation environment with two global variables
<ul>
<li><code>x</code> is the value to be matched against</li>
<li><code>s</code> is an array of objects
<ul>
<li>if the matching is occurring within the context of matching a list of Node Queries to a list of node references, the <em>i</em>th object in the array is a javascript object representation of a dereference of the <em>i</em>th node reference</li>
<li>otherwise, <code>s</code> is empty</li>
</ul></li>
</ul></li>
<li>execute the javascript code</li>
<li>yield the value produced by the last statement in the javascript code</li>
</ol></li>
<li><p>The integer value <code>-1</code> matches every node reference.</p></li>
<li><p>A set of integers matches a set of node references if each integer in the set of integers matches some node reference in the set of node references. Note that it is <em>not</em> necessary for every node reference to match some integer.</p></li>
<li><p>A set of string ↦ integer pairs <em>q</em> matches a set of string ↦ node reference pairs <em>s</em> if for each (<em>k1</em> ↦ <em>i</em>) in <em>q</em>, there is a (<em>k2</em> ↦ <em>r</em>) pair in <em>s</em> such that <em>k1</em> equals <em>k2</em> and <em>i</em> matches <em>r</em>.</p></li>
<li><p>A non-negative integer <em>i</em> matches a node reference <em>r</em> if and only if all of the following are true:</p>
<ol>
<li>there is a list of node references that was used to initiate the matching process</li>
<li>there is an element of that list at index <em>i</em></li>
<li>the node referenced by the element at the index <em>i</em> is a constituent of <em>r</em>.</li>
</ol></li>
<li><p>A list of node references matches a list of Node Queries if and only if both (1) they have the same length and (2) for each valid list index for the lists, the elements in the list of node reference at that index matches the element in the list of Node Queries at that index.</p></li>
<li><p>A Subject Query matches a reference to a Subject if the Subject Query's <code>from</code> matches the Subject's <code>source</code>.</p></li>
<li><p>A Subject Query matches a reference to an Aggregated Subject if the Subject Query's <code>from</code> matches the <code>parts</code> or <code>source</code> of any element of the Aggregated Subject's constituents.</p></li>
<li><p>An Expectation Query matches a reference to an Expectation if the two are equal.</p>
<p>No predicates or additional flexibility with regard to Expectation Queries are included in this specification in part to keep the type hierarchy of bounded depth (i.e., to avoid <em>X</em> predicate predicate … predicate types).</p>
<p>It is possible to define semantics-preserving reordering and re-indexing operations on Expectation's fields. This specification does not currently consider same-semantics different-order Expectations and Expecation Queries to match.</p></li>
<li><p>A Node Query other than a Subject Query or Expectation Query matches a node reference if and only if both (1) the referenced node and the Node Query are of the same node type and (2) each field in the Node Query matches the corresponding field in the referenced node.</p></li>
</ul>
<h3 id="instantiating-nodes-from-inferences">Instantiating Nodes from Inferences</h3>
<p>The <strong>instantiated node list</strong> of an Inference is defined to be a list of Nodes having the same length as the <code>consequent</code> of the <code>reason</code> of the Inference such that the Node at index <em>i</em> of the instantiated node list is created from the Node Template at index <em>i</em> of the <code>consequent</code> by doing all of the following (in any order)</p>
<ul>
<li><p>replacing any <code>application/javascript</code> producer values with the value yielded by the following</p>
<ol>
<li><p>create a javascript evaluation environment with one global variable <code>s</code>, an array of objects. The <em>i</em>th elements of <code>s</code> should be a javascript object representation of a dereference of the <em>i</em>th node reference in the <code>antecedents</code> if <em>i</em> is less than the number of antecedent elements; otherwise it should be a javascript object representation of the (<em>i</em> − <em>n</em>)th instantiated node, where <em>n</em> is the number of antecedent elements.</p></li>
<li>execute the javascript code</li>
<li><p>yield the value produced by the last statement in the javascript code</p></li>
</ol></li>
<li><p>replacing the <code>source</code> value (which is <code>-1</code> in Node Templates) with a reference to the Inference.</p></li>
<li><p>replacing any non-negative integers with the node reference in the <code>support</code> list at the integer's index if the integer is smaller than the length of the <code>support</code> list; otherwise with a reference to the node at index <em>i</em> − <em>n</em> of the instantiated node list being constructed, where <em>n</em> is the length of the <code>support</code> list.</p></li>
</ul>
<p>A Claim SHOULD NOT reference an Inference in its <code>source</code> field UNLESS it is an element of the instantiated node list of that Inference.</p>
<h1 id="known-string-and-datum-values">Known string and datum values</h1>
<p>The bulk of this section and its subsections will be added at a later time. What is present here is just an initial draft of a few example specifications.</p>
<h2 id="known-tag-keys">Known Tag <code>key</code>s</h2>
<p>To convert a known Tag <code>key</code> in this section to a URI or IRI, prepend it with the URI or IRI of this specification concatenated with &quot;/Tag/key#&quot;</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>key</code></th>
<th align="left">constraints</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">distinct</td>
<td align="left">≥ 2 elements in <code>of</code><br/>each elements referenced in <code>of</code> either a Subject or and Aggregated Subject</td>
<td align="left">no two elements of <code>of</code> refers to the same real-world subject</td>
</tr>
<tr class="even">
<td align="left">equivalent</td>
<td align="left">≥ 2 elements in <code>of</code></td>
<td align="left">the elements in <code>of</code> contain equivalent information (a hint that only one element needs to be displayed)</td>
</tr>
<tr class="odd">
<td align="left">same</td>
<td align="left">≥ 2 elements in <code>of</code><br/>each elements referenced in <code>of</code> either a Subject or and Aggregated Subject</td>
<td align="left">all of the elements of <code>of</code> refer to the same real-world subject</td>
</tr>
<tr class="even">
<td align="left">unsupported</td>
<td align="left"><code>of</code> contains a single reference to a Claim, Inference, or Derivation</td>
<td align="left">the <code>source</code> does not make this Claim or the <code>support</code> does not justify this Inference or Derivation</td>
</tr>
<tr class="odd">
<td align="left">wrong</td>
<td align="left"><code>of</code> cannot include both a &quot;wrong&quot; Tag and any element of that Tag's <code>of</code><br/><code>of</code> cannot include a Subject or Aggregated Subject</td>
<td align="left">the indicated node asserts a falsehood</td>
</tr>
</tbody>
</table>
<h2 id="known-property-keys">Known Property <code>key</code>s</h2>
<p>To convert a known Property <code>key</code> in this section to a URI or IRI, prepend it with the URI or IRI of this specification concatenated with &quot;/Property/key#&quot;</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>key</code></th>
<th align="left">constraints</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">type</td>
<td align="left"><code>value</code> is an enumerated type value<br/><code>of</code> is a Subject or Aggregated Subject</td>
<td align="left">what type of entity this subject refers to</td>
</tr>
</tbody>
</table>
<h3 id="known-enumerated-type-values">Known Enumerated Type Values</h3>
<p>To convert a value in this section to a URI or IRI, prepend it with the URI or IRI of this specification concatenated with &quot;/Subject/type/&quot;</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>IRI</code></th>
<th align="left">supertypes</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">person</td>
<td align="left"></td>
<td align="left">a human or putative human</td>
</tr>
<tr class="even">
<td align="left">event</td>
<td align="left"></td>
<td align="left">a distinct and recognisable (time period, location) pair or set thereof effecting or attempting to effect a common end</td>
</tr>
<tr class="odd">
<td align="left">birth</td>
<td align="left">event</td>
<td align="left">the coming forth of an infant from a womb, sometimes expanded to include related events such as conception, naming, legal registration, etc.</td>
</tr>
<tr class="even">
<td align="left">death</td>
<td align="left">event</td>
<td align="left">the transition from &quot;alive&quot; to &quot;dead&quot;</td>
</tr>
<tr class="odd">
<td align="left">place</td>
<td align="left"></td>
<td align="left">a location or region defined politically, geographically, socially, etc.</td>
</tr>
</tbody>
</table>
<p>The &quot;supertype&quot; column indicates an Expectation that derives supertype from subtype.</p>
<h2 id="known-connection-keys">Known Connection <code>key</code>s</h2>
<p>To convert a known Tag <code>key</code> in this section to a URI or IRI, prepend it with the URI or IRI of this specification concatenated with &quot;/Connection/key#&quot;</p>
<table>
<thead>
<tr class="header">
<th align="left"><code>key</code></th>
<th align="left">constraints</th>
<th align="left">meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">update</td>
<td align="left"><code>of</code> and <code>value</code> have same node type</td>
<td align="left">an error or inaccuracy in <code>of</code> has been corrected in <code>value</code></td>
</tr>
</tbody>
</table>
<h1 id="partial-implementation-and-extension">Partial Implementation and Extension</h1>
<p>For various reasons, implementers should expect to interact with other software that has adopted only portions of this specification and that have extended this specification in various ways. This section discusses appropriate ways to interact with partial implementations and extensions.</p>
<h2 id="policies-and-suggestions">Policies and Suggestions</h2>
<p>The set of elements in each node type is fixed, and MUST NOT be extended or reduced.</p>
<p>The set of node types MAY be extended, though it is RECOMMENDED that extensions be handled with custom <code>key</code>s in Properties, Connections, and/or Tags instead. It is RECOMMENDED that software ignore new node types when receiving extended data.</p>
<h3 id="partial-implementations-and-data-reductions">Partial implementations and data reductions</h3>
<h4 id="removing-unwanted-or-private-information">Removing unwanted or private information</h4>
<p>Software MAY chose to ignore any node or set of nodes when receiving a dataset provided that all nodes that depend upon the ignored node(s) are also ignored.</p>
<p>Software MAY chose to omit any node or set of nodes while sending a dataset provided that all nodes that depend upon the omitted node(s) are also omitted.</p>
<h4 id="removing-expectations-and-inferences">Removing Expectations and Inferences</h4>
<p>Software sending/receiving a dataset MAY chose to omit/ignore all Inferences and Expectations by converting each Inference into a Derivation with the same <code>support</code> as the Inference and a textual representation of the Expectation as the Derivation's <code>reason</code>. If the software is unable to convert the Expectation to text, it SHOULD use the text &quot;(reason omitted)&quot; as the Derivation's <code>reason</code>.</p>
<h4 id="removing-all-reasoning">Removing all reasoning</h4>
<p>Software sending/receiving a dataset MAY chose to omit/ignore all reasoning, reducing the dataset to a &quot;belief snapshot&quot;. Belief snapshots are datasets that satisfy the following constraints:</p>
<ul>
<li>Only five node types are used: Subject, Property, Connection, Derivation, and OutRef</li>
<li>Each Claim's <code>source</code> references a Derivation</li>
<li>Each element of each Derivation's <code>support</code> references an OutRef</li>
</ul>
<p>General datasets may be reduced to a belief snapshot via the following process:</p>
<ol>
<li>Create a Subject for each group of Nodes linked by &quot;same&quot; Tags. The new Subject's <code>source</code> should be a Derivation whose <code>support</code> is the set of all OutRef nodes in any of the original nodes' dependencies.</li>
<li>Copy all Properties and Connections that pointed to any of the the original nodes to point to the new node. The new Properties' and Connections' <code>source</code>s should be Derivations whose <code>support</code>s are the sets of all OutRef nodes in any of the original nodes' dependencies.</li>
<li>Replacing any set of Properties or Connections that differ only in <code>source</code> with a single node having as its <code>source</code> a Derivation with the union of the original claims' <code>source</code>s' <code>support</code> as the new Derivation's <code>support</code>.</li>
</ol>
<h3 id="handling-unsupported-values">Handling Unsupported Values</h3>
<h4 id="optional-predicates-and-producers">Optional predicates and producers</h4>
<p>When software that supports Expectation nodes receives a dataset including Expectations that contain predicates that the receiving software cannot evaluate (i.e., their contained scripts use aspects of the language that the software's Javascript engine does not support), it is RECOMMENDED that the recieving software keep the Expectation as received but treat the unsupported predicates as being equivalent to <em>Top</em> when error-checking received data and as equivalent to <code>false</code> when deciding if the user can create new Inferences based on the Expectation.</p>
<p>When software that supports Expectation nodes receives a dataset including Expectations that contain producers that the receiving software cannot evaluate, it is RECOMMENDED that the receiving software keep the Expectation as received but treat them as unchecked (like a Derivation).</p>
<h4 id="constrained-vocabularies">Constrained vocabularies</h4>
<p>If software desires a particular set of keys in its data, it is RECOMMENDED that a set of term-normalising Expectations be used to automatically create new Inferences and normalised terms upon receipt of new datasets, keeping the pre-normalised terms as <code>support</code> for the Inferences.</p>
<p>For software not supporting Expectations, it is RECOMMENDED that Derivations be used, resulting in a dataset equivalent to creating the Expectations and Inferences and then applying the process outlined in <a href="#removing-expectations-and-inferences">Removing Expectations and Inferences</a>. For software not supporting any reasoning, it is RECOMMENDED that the resulting dataset be equivalent to creating the Expectations and Inferences and then applying the process outlined in <a href="#removing-all-reasoning">Removing all reasoning</a>.</p>
<p>If the software does not know how to normalise a particular term, or does but does not care to represent the resulting normalised term, it MAY omit the term and its containing node, as outlined in <a href="#removing-unwanted-or-private-information">Removing unwanted or private information</a>.</p>
<h4 id="constrained-representations-and-topics">Constrained representations and topics</h4>
<p>If software desires a particular structure in its data, for example desiring birthdate Properties instead of birth Subjects, it is RECOMMENDED that a set of Expectations be used to automatically create new Inferences and normalised structures upon receipt of new datasets.</p>
<p>In some cases, software may decide to discard additional nodes; for example, software that tracks human relationships might chose to omit not only a &quot;species&quot;:&quot;horse&quot; Property but also the Subject to which it is attached and all other claims <code>of</code> that Subject.</p>
<h1 id="discussion">Discussion</h1>
<h2 id="node-identity-and-redundancy">Node Identity and Redundancy</h2>
<p>Node identity is determined only <a href="#equality">equality</a>. There is no notion of durable URI, UUID, GUID, DOI, PURL, ARK, or any other form of unique, durable identifier for a node in this specification, nor should one be introduced unless that identifier can be uniquely determined from the contents of the node alone, as for example a hash-based UUID. Equality does require access to the dependencies of a node, but because dependencies are acyclic that is always a finite set.</p>
<p>Because node contents determine node identity, there is no intrinsic notion of versions of a node, nor of updating or editing a node's contents. The concept that one node is an update of another should be expressed using a Connection with <code>key</code> &quot;update&quot;.</p>
<p>Because node identity is determined only by content, omitting nodes does not impede collaboration; the non-omitted nodes can still be linked to new research and shared between clients.</p>
<p>Some of the practices for removing information outlined in <a href="#partial-implementations-and-data-reductions">Partial implementations and data reductions</a> can &quot;replace&quot; nodes or introduce new nodes containing information that is redundant with previous data. Replacement doesn't actually modify or destroy any existing nodes, instead creating new, similar nodes. When the recipient sends these new nodes back to the sender the sender will now have nodes expressing redundant information. Retaining these redundant nodes in the dataset does not impede research provided that the user interface prevents redundant information from distracting the user, as (for example) displaying only one copy of a set of Properties that differ only in <code>source</code>. New nodes containing no new information could also be omitted upon receipt, assuming that the recipient can identify those nodes as redundant.</p>
<h2 id="term-normalisation">Term Normalisation</h2>
<p>When extracting the contents of an external source as a set of Claim nodes citing the OutRef of the external source, there is a quality-of-use expectation that the <code>slug</code> of each Subject be a description (in any language) of some specific part of the source that references the Subject in question; and that the various Properties and Connections reflect, as closely as possible, the language of the source (e.g., using a Connection with key <code>Papa</code> if that is the wording used to describe the relationship in the source).</p>
<p>Term normalisation should then happen by introducing new, normalised-term properties and connections <code>source</code>d to Inference or Derivation nodes that use the non-normalised terms as (part of) their <code>support</code>. In many cases, the <code>support</code> should also include the contextual information used in normalisation such as the date, location, and/or language of the underlying document.</p>
<h2 id="inferences-vs.-derivations-and-the-creation-of-expectations">Inferences vs. Derivations, and the creation of Expectations</h2>
<p>Inferences and Derivations are both intended to fulfil the same objective: to represent the fact that some claims were constructed using reasoning supported by other pieces of information within the dataset. Either Source type can be used to model any reasoning that is based on a finite set of other nodes. They differ primarily in that Inferences are more complicated to implement but are more language-independent and machine-understandable than Derivations.</p>
<p>The Derivation node does not require the use of Expectations and their associated Node Queries, Node Templates, matches, predicates, and producers. However, they leave the <code>reason</code> in machine-opaque human-language text, meaning that they are not readily analysed by the computer, are language-dependent, may lack necessary detail to communicate the reasoning process, may contain text not in keeping with their support, etc.</p>
<p>The Inference node is a machine-understandable representation of reasoning. However, Inferences require the creation of Expectation nodes, with the corresponding complexities of Node Queries, Node Templates, matches, predicates, and producers.</p>
<p>It is anticipated that some users of tools supporting Inference nodes will not be comfortable creating their own Expectations manually and will not be willing to limit themselves to a set of pre-built Expectations. The following set of steps is provided as a suggested way of assisting users in creating nontrivial Expectation nodes without needing to understand their underlying structure.</p>
<ol>
<li><p>Have the user specify the nodes they intend to infer and select the nodes they recognise as the support for their inference.</p>
<p>(This step would also be present in creating Derivations, and would be followed by asking the user to type a free-text explanation.)</p></li>
<li><p>Build a set of candidate antecedents from the nodes identified as support, augmented with any nodes referenced by the nodes identified as being inferred that are not already in the antecedent or inferred collections.</p></li>
<li><p>For each field of each candidate antecedent (except the fields of an OutRef; see below), ask the user &quot;is this field important to your reasoning?&quot; If the answer is &quot;no&quot;, replace the field with <code>-1</code> (if a node reference) or predicate <em>Top</em> (otherwise). If the answer is &quot;yes&quot;, add the referenced node to the candidate antecedent set (if a node reference) or replace it with a literal predicate (otherwise). Continue until you have asked about all nodes of all fields in the antecedent set.</p>
<p>For the <code>details</code> field of an OutRef, instead ask this question of each pair in the set and, if the answer is &quot;no&quot;, remove the pair completely.</p>
<p>For the <code>parents</code> field of an OutRef, instead ask this question of each pair in the set and, if the answer is &quot;no&quot;, remove the pair completely; if it the answer is &quot;yes&quot;, add the referenced OutRef to the candidate antecedent set.</p>
<p>You could optionally ask additional questions to build more advanced predicates; for example, to create a <code>x == s[i][j]</code> predicate you could ask something like &quot;we notice that these two nodes both have the same <code>value</code>; is that same-value characteristic important?&quot;</p></li>
<li><p>Order the candidate antecedents such that, if node <em>A</em> is in node <em>B</em>'s dependencies and both are antecedents then <em>A</em> appears before <em>B</em>. Use this ordering to populate the <code>antecedent</code> list and to replace node references with integers.</p>
<p>There may be many orderings that satisfy this requirement. Future versions of this specification might recommend a particular canonical ordering in order to reduce variability in Expection nodes.</p></li>
<li><p>Organise the inferred nodes such that, if node <em>A</em> is in node <em>B</em>'s dependencies and both are being inferred then <em>A</em> appears before <em>B</em>. Use this ordering to populate the <code>consequent</code> list and to replace node references with integers. Additionally, replace all inferred node <code>source</code> values with <code>-1</code>, as required by the definition of Node Template.</p>
<p>There may be many orderings that satisfy this requirement. Future versions of this specification might recommend a particular canonical ordering in order to reduce variability in Expection nodes.</p></li>
</ol>
<h1 id="examples">Examples</h1>
<h2 id="example-1-ad-hoc-notation-working-with-a-single-source-document">Example 1: ad-hoc notation, working with a single source document</h2>
<p>This is a hasty example utilizing ad-hoc notation, including fairly arbitrary mixing of strings from various ontologies and strings of my own creation, displaying (type,language,value) triples as strings, and so on. Its goal is simply to present one possible use for this model.</p>
<p>As suggested by Rob Hoare, the basis for this example is <a href="https://familysearch.org/ark:/61903/1:1:MS79-1S8" class="uri">https://familysearch.org/ark:/61903/1:1:MS79-1S8</a></p>
<p style="background-color:#f70">This example is based on an oler version of this specification; updating it is on my to-do list. — Luther</p>
<hr />
<p>First, I'd make an OutRef for the source. Let's make two, so we can see what the parents field is for, one for the 1900 census and one for the particular part of it in question:</p>
<pre><code>O1. OutRef(parents={},
      details={&quot;type&quot;:&quot;Census&quot;,&quot;country&quot;:&quot;United States&quot;,&quot;year&quot;:&quot;1900&quot;,...})
O2. OutRef(parents={O2},
      details={&quot;district&quot;:&quot;1006&quot;,&quot;sheet&quot;:&quot;9A&quot;,...}</code></pre>
<p>Note that I expect this model to be replaced by the S&amp;CEG's work, but I needed a filler to make a self-contained example specification.</p>
<p>Next, I'd document what that one source claims. Part of that would be</p>
<pre><code>S1. Subject(slug=&quot;person of line 14&quot;)
P1. Property(source=O2, key=&quot;family name&quot;, of=S1, value=&quot;Smith&quot;)
P2. Property(source=O2, key=&quot;given name&quot;, of=S1, value=&quot;Magdoline&quot;)
P3. Property(source=O2, key=&quot;DATE OF BIRTH&quot;, of=S1, value=&quot;Aug 1882&quot;)
P4. Property(source=O2, key=&quot;Age at last birthday&quot;, of=S1, value=&quot;17&quot;)
P5. Property(source=O2, key=&quot;Place of birth&quot;, of=S1, value=&quot;Illinois&quot;)

S2. Subject(source=O2, slug=&quot;person of line 10&quot;)
P6. Property(source=O2, key=&quot;family name&quot;, of=S2, value=&quot;Smith&quot;)
P7. Property(source=O2, key=&quot;given name&quot;, of=S2, value=&quot;William&quot;)

S3. Subject(source=O2, slug=&quot;household of lines 10-17&quot;)

C1. Connection(source=O2, key=&quot;Head&quot;, of=S3, value=S2)
C2. Connection(source=O2, key=&quot;member&quot;, of=S3, value=S1)
C3. Connection(source=O2, key=&quot;Daughter&quot;, of=S2, value=S1)

P8. Property(source=O2, key=&quot;enumerated date&quot;, of=O2, value=&quot;+1900-06-07&quot;)</code></pre>
<p>So far this is essentially just RDF-like triples with identifiers and sources. Now for some reasoning. Let's start simple, just a term normalisation:</p>
<pre><code>E1. Expectation(antecedent=[
        SubjectQuery(from=-1),
        PropertyQuery(source=-1, key=Regex(&quot;/place of birth/i&quot;, of=0, value=Top)
    ], consequent=[
        PropertyTemplate(key=&quot;http://schema.org/birthPlace&quot;, of=0, value=Lookup(1,3))
    ])</code></pre>
<p>A rough English translation of that expectation is</p>
<blockquote>
<p>Given something with a &quot;place of birth&quot; property, you can infer a <code>http://schema.org/birthPlace</code> property with the same value.</p>
</blockquote>
<p>That expressed the idea that any &quot;place of birth&quot; key, such as this census uses for its column header, can be converted into a particular standardised term. I'd apply it as</p>
<pre><code>I1. Inference(support=[S1,P5], reason=E1)
P9. Property(source=I1, key=&quot;http://schema.org/birthPlace&quot;, of=S1, value=&quot;Illinois&quot;)</code></pre>
<p>I could also infer a birth date from the age; since my current list of producers does not include arithmetic, I'd either use a Script predicate or a Derivation such as</p>
<pre><code>D1. Derivation(antecedents={P4,P8}, reason=&quot;Birth date can be derived from age&quot;)
S4. Subject(source=D1, slug=&quot;inferred birth&quot;)
C4. Connection(source=D1, key=&quot;child&quot;, of=S4, value=S1)
P10. Property(source=D1, key=&quot;type&quot;, of=S4, value=&quot;http://gedcomx.org/Birth&quot;)
P11. Property(source=D1, key=&quot;date&quot;, of=S4, value=&quot;A+1882-06-07/1983-06-07&quot;)</code></pre>
<p>Note here I've chosen to add a birth event instead of a birthdate; I could normalise that too:</p>
<pre><code>E2. Expectation(antecedent=[
        SubjectQuery(from=-1),
        PropertyQuery(source=-1, key=Lit(&quot;type&quot;), of=0, value=Lit(&quot;http://gedcomx.org/Birth&quot;)),
        PropertyQuery(source=-1, key=Lit(&quot;date&quot;), of=0, value=Top),
        SubjectQuery(from=-1),
        ConnectionQuery(source=-1, key=lit(&quot;child&quot;), of=0, value=3)
    ], consequent=[
        PropertyTemplate(source=-1, key=&quot;birthdate&quot;, of=3, value=Lookup(2,3))
    ])
I2. Inference(support=[S4,P10,P11,S1,C4], reason=E2)
P12. Property(source=I2, key=&quot;birthdate&quot;, of=S1, value=&quot;A+1882-06-07/1883-06-07&quot;)</code></pre>
<p>A rough English translation of expectation E2 is</p>
<blockquote>
<p>Given a birth event with a date property and an entity participating in the birth as a child, you can infer the birthdate of the child to be the date of the event.</p>
</blockquote>
<p>P12 and P3 agree, with P3 more precise than P12, but I'd leave them both in the data since they are both claims supported by O2 and let the user interface handle displaying just one of the two.</p>
</body>
</html>
